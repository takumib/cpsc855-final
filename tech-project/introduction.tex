\section{Introduction}
\label{sec:intro}
Within little more than a decade, the area of embedded network systems and wireless sensing has exploded in popularity within industry and academia alike. With this quick and widespread proliferation of embedded devices, the need for provably correct embedded code increases -- especially in those industries where the cost of failure could be extreme both in terms of cost and human life. 

From a non-verification related perspective, a variety of tools and languages have been put forth to help make developing embedded applications a simpler, less error prone endeavor. On one end of this effort are languages such as NesC, (Network embedded sensor C) which strive to minimize concurrency issues and other common sources of error by hiding libraries of pre-written drivers underneath hierarchies of software and interface level abstractions. The other end of this effort is largely comprised of simulation tools such as TOSSIM, Cooja, and Avrora that make use of high-fidelity simulations to model networks offline in controlled, repeatable environments. Though these and other tools have indeed proven invaluable in allowing users to test and reason about event-driven code prior to deployment, they remain incapable of providing complete assurance that code will behave as expected when deployed.

We approach this problem by using RESOLVE (Reusable SOftware Language with VErification) as means of authoring, specifying, and ultimately verifying code, prior to execution, for embedded network systems. Our decision to use RESOLVE as a language frontend -- as opposed to verifying C code directly -- ultimately stems from a verification amenability standpoint: Not only does RESOLVE prohibit verification crippling operations such as uncontrolled referencing and aliasing (prevalent in C and many other current languages)\cite{kulczycki:2004}, but also embodies a number of other characteristics ideal for embedded platforms including:

\begin{itemize}
\item \textbf{Modularity} RESOLVE enforces a strict separation of concerns between module level specifications and client level implementations. As a result, for any one particular specification, there can be any number of interchangeable implementations. This separation is ideal considering that many embedded applications happen to fit this pattern nicely: Various drivers oftentimes provide a common set of functionality, but in general have many distinct implementations that vary arbitrarily from platform to platform, vendor to vendor.

\item \textbf{Mathematical flexibility} RESOLVE offers a rich, mathematical type system that allows users to either draw from a library of pre-existing mathematical units when writing specifications, or simply create their own. This is ideal in a setting where drivers might encompass a wide spectrum possible applications -- each requiring new mathematical developments.

\end{itemize}

The paper is organized as follows: First, we open with a brief overview of the Telos mote platform. Next, we present revised specifications of an LED driver component with a formally verified enhancement. This section is concluded with a review of verification results, and a discussion of any relevant theorems and verification conditions (VCs) used. The remainder of the paper is spent detailing the model of C code generated by the tool, giving a quick overview of generation process itself, and detailing a dynamic, stack-based memory allocation tool utilized by the translated code. We conclude with suggestions for tool improvements, as well as a review of some long term research goals.