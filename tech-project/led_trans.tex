\section{Putting It All Together}

\begin{figure*}
\begin{minipage}{0.4\textwidth}
\begin{verbatim}
/*
 * Generated by the RESOLVE to C translator. 
 * This file should not be modified.
 */
#ifndef __LED_TELOS_DEMO_H
#define __LED_TELOS_DEMO_H

#include ".../RESOLVE.h"
  ...
#include ".../Concepts/.../LED_Template.h"
#include ".../Concepts/.../Std_LED_Realiz.h"
#include ".../Concepts/.../Toggling_Realiz.h"

typedef struct LED_Facility LED_Facility;
struct LED_Facility {
    LED_Template* core;
    Toggling_Capability_for_LED_Template* 
                      Toggling_Capability;
};
LED_Facility LED_Fac_Var;

void LED_Telos_Demo_create();
void LED_Telos_Demo_destroy();
#endif
\end{verbatim}
\end{minipage}
\hspace{1.5cm} 
\begin{minipage}{0.4\textwidth}
\begin{verbatim}
#include "LED_Telos_Demo.h"

void LED_Telos_Demo_create() {
  Std_Bool_Fac_create();
  Std_Int_Fac_create();
  Std_Clock_Fac_create();
  r_type_ptr __arg_0 = Std_Int_Fac_Var.core->
    createFromInt(3, Std_Int_Fac_Var.core->Integer);
  LED_Fac_Var.core = 
    new_Std_LED_Realiz_for_LED_Template(__arg_0);
  LED_Fac_Var.Toggling_Capability = 
    new_Toggling_Realiz_for_Toggling_Capability_
    of_LED_Template(LED_Fac_Var.core);
  Std_Int_Fac_Var.core->Integer->
    destroy(__arg_0, Std_Int_Fac_Var.core->Integer);
}

void LED_Telos_Demo_destroy() {
    free_Std_LED_Realiz_for_LED_Template(
    				    LED_Fac_Var.core);
    Std_Bool_Fac_destroy();
    Std_Int_Fac_destroy();
} ...
\end{verbatim}
\end{minipage}
\caption{C Translation of \texttt{LED\_Telos\_Demo}.}
\label{fig:demo}
\end{figure*}

Given our RESOLVE realization of the \texttt{LED\_Telos\_Demo} described in Section 3, we now discuss our translator's output in greater detail.

Depicted in figure \ref{fig:demo} is the C translation of \texttt{LED\_Telos\_Demo} consisting of a .h (left) and a portion of the .c (right). The \texttt{LED\_Telos\_Demo\_create()} function provides instantiations for all global facilities used in \texttt{LED\_Telos\_Demo}, including those for standard types such as integers, booleans, clock, as well as local facilities such as \texttt{Leds\_Fac}. One additional thing to note within this create method is the temporary \texttt{\_\_arg\_0} integer variable -- representing the formal value \texttt{Strip\_Length} found within the concept. Note that this variable does not appear in the original source, but rather, is created by the translator in an effort to keep track of all literal argument values that require manual deletion.

The \texttt{Leds\_Fac} facility from the original source, represented here as a struct, uses a \texttt{core} field to provide a means of accessing the methods and types in the original concept, while any remaining fields correspond to enhancement pointers that serve a similar end -- in this case, providing access to the operations declared within  \texttt{Toggling\_Capability}.

Clearly facilities and other modules highly reliant on facility instantiations are no doubt going to consume much more memory than the small example detailed here. To help alleviate some of th

%\texttt{new\_Toggling\_Realiz\_for\_Toggling\_Capability\_of\_LED\_Template()}. Similarly, this initialization and allocation step must occur for the Integer, Boolean, and Clock facilities. From this relatively small example of LED toggling from RESOLVE to C,  complex programs will require even more attention to amount of memory used for each concept and facility realization. Curtailing the management of this memory by placing the responsibility on an allocator provides a key motivation for using \texttt{salloc()} and \texttt{sfree()}.

%As seen from above, RESOLVE to C translations can produce verbose output. The code presented to the right introduces pseudocode for a toggling capability of an LED strip to simplify understanding of control flow. Denoting an LED strip as \texttt{L} and the index represented as an integer literal, this example toggles each LED \footnote{in the case of the telos motes, we will consider the LED strip to have an LED\{0, 1, 2\}} successively, separated by a 500ms delay and is repeated indefinitely through a while-loop.

%Within \texttt{Toggle()}, we use the externally realized LED concepts \texttt{Status()} to get the current state of an LED strip, and \texttt{Set()} to set the specified LED at an index to complement. Retrieving the status, as well as setting an LED strip at an index to on or off requires more memory allocation to save these to temporary Boolean and Integer types. In this instance, we note that we need to have the capability of creating and destroying an arbitrary number of times, provides another key motivation for dynamic memory allocation. Determining the minimum memory size needed, becomes increasingly difficult with the while statement. Similarly, other programs may require an implementation of stacks or queues that require a locally unbounded depth. 

%Turning to the \texttt{main} function, we first call the appropriate create function to instantiate and allocate all global variables required by the facility. We then make a call to the user supplied \texttt{Main()} operation, which performs the user code. In normal applications the destroy method will be invoked, however here we employ a busy which prevents it from ever being called.

%A wait utility is then called using the \texttt{Std\_Clock\_Fac} facility. This facility uses the externally realized concept to the msp430 \texttt{\_\_delay\_cycles()} command. Internally the MCU is delayed for a given number of cycles. 

\begin{figure}
\begin{verbatim}
int Main() {
  while(TRUE) {
    Toggle(L, 0);
    Wait_500_Milli_Seconds();
    Toggle(L, 1);
    Wait_500_Milli_Seconds();
    Toggle(L, 2);
    Wait_500_Milli_Seconds();
  }
}

int main() {
  LED_Telos_Demo_create();
  Main();
  LED_Telos_Demo_destroy();
}
\end{verbatim}
\label{fig:loop}
\end{figure}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
