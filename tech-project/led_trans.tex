% An LED Demo Translation
\section{Putting It All Together}

\begin{figure*}
\begin{minipage}{0.4\textwidth}
\begin{verbatim}
/*
 * Generated by the RESOLVE to C translator. 
 * This file should not be modified.
 */
#ifndef __LED_TELOS_DEMO_H
#define __LED_TELOS_DEMO_H

#include ".../RESOLVE.h"
#include ".../Facilities/.../Std_Bool_Fac.h"
#include ".../Facilities/.../Std_Int_Fac.h"
#include ".../Facilities/.../Std_Clock_Fac.h"
#include ".../Concepts/.../LED_Template.h"
#include ".../Concepts/.../Std_LED_Realiz.h"
#include ".../Concepts/.../Toggling_Realiz.h"

typedef struct LED_Facility LED_Facility;
struct LED_Facility {
    LED_Template* core;
    Toggling_Capability_for_LED_Template* 
                      Toggling_Capability;
};
LED_Facility LED_Fac_Var;

void LED_Telos_Demo_create();
void LED_Telos_Demo_destroy();
#endif
\end{verbatim}
\end{minipage}
\hspace{1.5cm} 
\begin{minipage}{0.4\textwidth}
\begin{verbatim}
/*
 * Generated by the RESOLVE to C translator. 
 * This file should not be modified.
 */
#include "LED_Telos_Demo.h"

void LED_Telos_Demo_create() {
  Std_Bool_Fac_create();
  Std_Int_Fac_create();
  Std_Clock_Fac_create();
  r_type_ptr __arg_0 = Std_Int_Fac_Var.core->
    createFromInt(3, Std_Int_Fac_Var.core->Integer);
  LED_Fac_Var.core = 
    new_Std_LED_Realiz_for_LED_Template(__arg_0);
  LED_Fac_Var.Toggling_Capability = 
    new_Toggling_Realiz_for_
    Toggling_Capability_of_LED_
    Template(LED_Fac_Var.core);
  Std_Int_Fac_Var.core->Integer->
    destroy(__arg_0, Std_Int_Fac_Var.core->Integer);
}

void LED_Telos_Demo_destroy() {
    free_Std_LED_Realiz_for_LED_Template(
    				    LED_Fac_Var.core);
    Std_Bool_Fac_destroy();
    Std_Int_Fac_destroy();
}
        ...
\end{verbatim}
\end{minipage}
\label{fig:demo}
\end{figure*}

We have seen in Figure~\ref{fig:relationship} that RESOLVE facilities have corresponding \texttt{.h/c} output translations. Shown in Figure~\ref{fig:demo}, is an example facility realization for an LED strip with a toggling enhancement. Again, note, that the header file contains instantiation information for an LED facility.

%The \texttt{.h} file contains a struct that holds an instance of an LED concept realization as well as the realization for a toggling enhancement. Take note that additional facility and concept imports are placed here corresponding to Figure~\ref{fig:relationship}, including create and destroy constructs as mentioned in Section~\ref{sec:impl}.

In the \texttt{C} implementation file, the \texttt{LED\_Telos\_Demo\_create()} function provides instantiations for all the global facilities used for the \texttt{LED\_Telos\_Demo} program, including those for standard types (Integer \& Boolean), Clock, and the LED. To instantiate a new LED facility we must first create a new Integer realization and save it into a new \texttt{r\_type\_ptr}\footnote{An r\_type\_ptr provides the primary source of object storage in RESOLVE. It is represented as a (\texttt{void**} ) in its C representation. Although it is not detailed in this paper, the r\_type\_ptr provides the level abstraction needed to implement an object oriented design in C}. This new Integer realization will provide the strip length for the LED facility. A new facility can then use this to create a new concept using the externally realized \texttt{new\_Std\_LED\_Realiz\_for\_LED\_Template()} function. The facility can also create a new enhancement with \texttt{new\_Toggling\_Realiz\_for\_Toggling\_Capability\_of\_LED\_Template()}. Similarly, this initialization and allocation step must occur for the Integer, Boolean, and Clock facilities. From this relatively small example of LED toggling from RESOLVE to C,  complex programs will require even more attention to amount of memory used for each concept and facility realization. Curtailing the management of this memory by placing the responsibility on an allocator provides a key motivation for using \texttt{salloc()} and \texttt{sfree()}.

%From this relatively small example of LED toggling from RESOLVE to C, we expect even These externally realized components utilize the memory allocator presented in Section~\ref{sec:mem}. 

%The corresponding \texttt{.c} file provides implementations for creating, destroying, as well as providing the execution implementation for the LED strip. Take note that \texttt{LED\_Telos\_Demo\_create()} provides additional functionality besides creating a new instance of an LED facility. Creating a new facility requires that all accompanying facilities are instantiated at this point, including those from Standard and Clock\footnote{The Std\_Clock\_Fac provides and externally realized facility to express sleep functionality for an msp430 chipset} for this example. To instantiate a new LED facility we must first create a new Integer realization and save it into a new \texttt{r\_type\_ptr}\footnote{An r\_type\_ptr provides the primary source of object storage in RESOLVE. It is represented as a (\texttt{void**} ) in its C representation. Although it is not discussed in this paper, the r\_type\_ptr provides the level abstraction needed to implement an object oriented design in C}. This new Integer realization will provide the strip length for the LED facility. A new facility can then be instantiated by calling the \texttt{new\_Std\_LED\_Realiz\_for\_LED\_Template()} function. This is where memory is allocated and stored for a new LED facility and its enhancements. Once a facility is instantiated, we can create a new realization for LED toggling and store this as a part of the facility in \texttt{LED\_Fac\_Var.Toggling\_Capability}.

%Since an LED strip is specified by Std_Boolean and Std_Integer, we must create instantiations of both facilities. We must also include \texttt{Std_Clock_Fac_create())} because our LED toggling program will utilize the msp430 clock utilities to put the MCU to sleep. 

\begin{figure}
\begin{verbatim}
void Main() {
  r_type_ptr L = LED_Fac_Var.core->LED->
    create(LED_Fac_Var.core->LED);
  r_type_ptr Loop = ...createFromBoolean(1, ...);
  r_type_ptr I0 = ... createFromInteger(0, ...);
  r_type_ptr I1 = ... createFromInteger(1, ...);
  r_type_ptr I2 = ... createFromInteger(2, ...);
	
  while(**(int**)Loop) {
    LED_Facility_Var.Toggling_Capability->
      Toggle(L, I0, LED_Fac_Var.Toggling_Capability);
    Std_Clock_Fac_Var.core->
      Wait_500_Milli_Seconds(Std_Clock_Fac_Var.core);
    LED_Fac_Var.Toggling_Capability->
      Toggle(L, I1, LED_Fac_Var.Toggling_Capability);
    Std_Clock_Fac_Var.core->
      Wait_500_Milli_Seconds(Std_Clock_Fac_Var.core);
    LED_Fac_Var.Toggling_Capability->
      Toggle(L, I2, LED_Fac_Var.Toggling_Capability);
    Std_Clock_Fac_Var.core->
      Wait_500_Milli_Seconds(Std_Clock_Fac_Var.core);
  }

  Std_Int_Fac_Var.core->Integer->
  ...
  LED_Fac_Var.core->LED->
    destroy(L, LED_Fac_Var.core->LED);
}
\end{verbatim}
\label{fig:loop}
\end{figure}

The code presented by Figure~\ref{fig:loop} introduces the toggling capability for an LED strip. It toggles each LED\footnote{in the case of the telos motes, we will consider the LED strip to have an LED\{0, 1, 2\}}, separated by a delay of 500ms. This is repeated indefinitely using a while statement.

To implement this, realizations for the local LED strip, the loop condition, and the index for each LED must be created as demonstrated. Within the loop, we call the \texttt{Toggle()} function from the \texttt{Toggling\_Capability} enhancement created from Figure~\ref{fig:demo}. 

%An instance of a new LED strip must be created from the facility to denote a new, local, LED realization. Other local facilities, must be instantiated, including a Boolean, \texttt{Loop}, which provides the loop condition as well as Integers I0, I1, and I2 which will denote a specific index of an LED\footnote{in the case of the telos motes, we will consider the LED strip to have an LED\{0, 1, 2\}.} Within the loop, we call the \texttt{Toggle()} function from the \texttt{Toggling\_Capability} enhancement created from Figure~\ref{fig:demo}. 

The toggling realization takes an LED strip, the index to toggle, and the reference to the enhancement. Within \texttt{Toggle()}, we use the externally realized LED concepts \texttt{Status()} to get the current state of the LED, and \texttt{Set()} to flip the specified LED at an index to its opposite value (on or off). Retrieving the status, as well as setting an LED strip at an index to on or off requires more memory allocation to save these to temporary Boolean and Integer types. In this instance, we note that we need to have the capability of creating and destroying an arbitrary number of times, provides another key motivation for dynamic memory allocation. Determining the minimum memory size needed, becomes increasingly difficult with the while statement. Similarly, other programs may require an implementation of stacks or queues that require a locally unbounded depth. 

A wait utility is then called using the \texttt{Std\_Clock\_Fac} facility. This facility uses the externally realized concept to the msp430 \texttt{\_\_delay\_cycles()} command. Internally the MCU is delayed for a given number of cycles. 

%
%
%
%
%
%
%
%
%
%
%
%
%
%
