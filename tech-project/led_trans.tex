\section{EVALUATION}

\begin{figure*}
\begin{minipage}{0.4\textwidth}
\begin{verbatim}
/*
 * Generated by the RESOLVE to C translator. 
 * This file should not be modified.
 */
#ifndef __LED_TELOS_DEMO_H
#define __LED_TELOS_DEMO_H

#include ".../RESOLVE.h"
  ...
#include ".../Concepts/.../LED_Template.h"
#include ".../Concepts/.../Std_LED_Realiz.h"
#include ".../Concepts/.../Toggling_Realiz.h"

typedef struct LED_Facility LED_Facility;
struct LED_Facility {
    LED_Template* core;
    Toggling_Capability_for_LED_Template* 
                      Toggling_Capability;
};
LED_Facility LED_Fac_Var;

void LED_Telos_Demo_create();
void LED_Telos_Demo_destroy();
#endif
\end{verbatim}
\end{minipage}
\hspace{1.5cm} 
\begin{minipage}{0.4\textwidth}
\begin{verbatim}
#include "LED_Telos_Demo.h"

void LED_Telos_Demo_create() {
  Std_Bool_Fac_create();
  Std_Int_Fac_create();
  Std_Clock_Fac_create();
  r_type_ptr __arg_0 = Std_Int_Fac_Var.core->
    createFromInt(3, Std_Int_Fac_Var.core->Integer);
  LED_Fac_Var.core = 
    new_Std_LED_Realiz_for_LED_Template(__arg_0);
  LED_Fac_Var.Toggling_Capability = 
    new_Toggling_Realiz_for_Toggling_Capability_
    of_LED_Template(LED_Fac_Var.core);
  Std_Int_Fac_Var.core->Integer->
    destroy(__arg_0, Std_Int_Fac_Var.core->Integer);
}

void LED_Telos_Demo_destroy() {
    free_Std_LED_Realiz_for_LED_Template(
    				    LED_Fac_Var.core);
    Std_Bool_Fac_destroy();
    Std_Int_Fac_destroy();
} ...
\end{verbatim}
\end{minipage}
\caption{C Translation of \texttt{LED\_Telos\_Demo}. The .h (left) and .c implementation (right).}
\label{fig:demo}
\end{figure*}

Given our RESOLVE realization of the \texttt{LED\_Telos\_Demo} described in Section 3, we now discuss our translator's output in greater detail.

Depicted in figure \ref{fig:demo} is the C translation of \texttt{LED\_Telos\_Demo} consisting of a .h (left) and a portion of the .c (right). The \texttt{LED\_Telos\_Demo\_create()} function provides instantiations for all global facilities used in \texttt{LED\_Telos\_Demo}, including those for standard types such as integers, booleans, clock, as well as local facilities such as \texttt{LED\_Fac}. One additional thing to note within this create method is the temporary \texttt{\_\_arg\_0} integer variable -- representing the formal value \texttt{Strip\_Length} found within the concept. Note that this variable does not appear in the original source, but rather, is created by the translator in an effort to keep track of all literal argument values that require manual deletion (as illustrated after the assignment of \texttt{Toggling\_Capability}).

The \texttt{LED\_Fac} facility from the original source, represented here as a struct, uses a \texttt{core} field to access the methods and types found in the original concept, while any remaining fields correspond to enhancement pointers that serve a similar end -- in this case, providing access to the operations declared within  \texttt{Toggling\_Capability}.

Clearly, facilities and other modules highly reliant on instantiated facilities are no doubt going to consume much more memory than the small example detailed here -- as each would (naively) be represented as a struct. To help alleviate some of this memory usage, we make special considerations in the translator to only create structs for \textit{enhanced} facilities. That is, \textit{unenhanced} facilities (comprising structs with only a single \texttt{core} field) are not created, but rather, dereferenced manually within the source via their \texttt{core} field.

The body of the .c file (omitted from Figure \ref{fig:demo} for reasons of clarity and space), operates largely as one would expect: A while loop iterates indefinitely, making successive, 500ms delayed calls to toggle each LED. Since calls to \texttt{Set}, \texttt{Status}, and \texttt{Toggle} involved in some form or another within this loop, we note that the the task of allocating and deallocating memory used by the local variables within these methods falls to our dynamic allocator.

The main method we use to invoke this logic is shown below. 

\begin{verbatim}
int main() {
    LED_Telos_Demo_create();
    Main();
    LED_Telos_Demo_destroy();
}
\end{verbatim}As facility modules are the source of all execution in RESOLVE, this is an ideal place to instantiate all required elements using single call to our facility-defined create method. After execution has completed, the destroy method deallocates all globally declared facilities and variables. Note that the call to destroy for each individual type, in turn calls a similar destroy method defined within the realization for that particular type, resulting in a cascade effect of deallocation.

