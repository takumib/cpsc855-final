\section{Related Work}

There are a number of existing systems and techniques geared towards verification of embedded programs written in C. While we discuss only a handful here, readers interested in learning more about the systems and approaches mentioned are encouraged to refer to the references provided for each. 

The first approach, bounded model checking, is the main focus of the work detailed in \ref{cordeiro:2009}. 

%Though RESOLVE is the only system we know of that proves, prior to compilation, the full functional correctness of embedded software, there are a number of other systems that 


%Another system, also a Microsoft research endeavor, is VCC -- a system designed for the verification of C programs \cite{vcc:2009}. One of the main draws of VCC is that it has mechanisms for verification of concurrent code -- an ideal feature when presented with asynchronous, event driven code common in most embedded applications. 

%RESOLVE differs from the projects mentioned above most notably in that it does not make use of third party automated provers or decision procedures to discharge verification conditions. Rather, it makes use of an integrated, minimalist term rewrite prover that applies higher order theorems and definitions in attempting to transform givens into a provable goal. 

% shortcoming -- concurrency.

\section{Discussion and Future Work}

Using embedded application development as an example, we perceive this work as a step towards more fully exploring the role of formal verification in lower level system-oriented contexts. Indeed, the realm of embedded systems provides an ideal stepping off point for this challenge, as it encourages (and indeed, requires) RESOLVE to provide support for not only new target languages (namely C), but also new language constructs that give the user the ability to author drivers required for any serious embedded application. While we have made progress with the latter in the form of the externally keyword, a natural direction for future work would entail using RESOLVE's performance specification mechanisms to prove the time and duration estimates for a memory allocator, not unlike the one presented here. Indeed, by being able to prove aspects of this system at time and space level granularity, the question of whether our programs will exhaust stack space becomes a non-issue, as we will be assured -- prior to execution -- that we are within the systems limitations.

Further, an additional language characteristic that we feel would be beneficial is having some means of dictating \textit{static objects}. While RESOLVE makes considerations for single instance concepts that are tied to particular facility instantiations, we currently have no means of strictly limiting how many instantiations of a particular facility there might be (not even via standard facilities). Thus, in terms of specifying concepts such as clocks, LED strips, and other hardware-centric concepts that only appear once on a circuit board, RESOLVE could benefit from a mechanism that restricts allowable instances of these and other objects. 

\section{Conclusion}

In this paper we present a new RESOLVE language construct, and a translation tool that aims to produce an accurate, embedded platform-friendly C representation of RESOLVE. We provide representative specifications of an LED strip component that both demonstrates the benefits of RESOLVE's approach to reusable mathematical developments, as well as formal verification of a single driver enhancement. We illustrate usage of this component in the context of a client facility module, wherein we introduce the externally keyword that allows users to transparently pair non-native RESOLVE implementations with native RESOLVE specifications. We then translate this facility application, illustrating a proof-of-concept dynamic memory allocator working in tandem with what we consider to be an accurate C representation of RESOLVE code. The examples and results listed in this paper have been successfully run on a Telosb mote, and the overall tool -- now fully integrated with the RESOLVE compiler -- actively continues to undergo improvements and optimizations on all fronts.
