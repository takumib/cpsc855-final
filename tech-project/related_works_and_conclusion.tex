\section{Related Work}

There are a number of existing systems that ultimately seek to prove the functional correctness of programs. While we discuss only a handful here, readers interested in learning more about the systems mentioned might to refer to \cite{klebanov:2011} for a more in depth discussion. Perhaps most notable among the systems we list here (and perhaps the closest to RESOLVE's approach) is Microsoft research's Dafny \cite{leino:2010}. Designed to be capable of verifying pointer based structures, Dafny currently stands as one of the more popular approaches. Replacing RESOLVE's notion of mathematical variables with what are termed `ghost' variables, reasoning is kept, like RESOLVE, disconnected from implementation-level code. Dafny uses an intermediate verification language, termed Boogie, to generate verification conditions which are then dispatched via Z3, Microsoft's automated prover. 

Another system worth mentioning here is VCC, also a Microsoft research project, which is designed for the verification of C programs. 

% shortcoming -- concurrency.

\section{Discussion and Future Work}

Using embedded application development as an example, we envision the work presented in this paper as a step towards more fully exploring the role of formal verification in lower level system-oriented contexts. Indeed, the realm of embedded systems has served as an ideal stepping off point for this challenge, as it encourages (or, indeed, requires) RESOLVE as a language to expand to provide support for not only new target languages (namely C), but also new language constructs that give the user freedom to more easily author drivers of the sort required for any serious embedded application. While we have made some progress with the latter in the form of the externally keyword, a natural direction for future work should involve moving beyond functional correctness, and instead focus more heavily on RESOLVE's mechanisms for specifying time and duration. With performance capabilities such as these in place, a natural next step in this work would be to formally specify and externally realize a simple memory allocation scheme, not dissimilar to the one presented in this paper.

Another language characteristic that we feel would benefit especially specification of lower level applications is having some means within RESOLVE of dictating \textit{static objects}. While currently RESOLVE allows users create single instance concepts that are tied to particular facility instantiations, we currently have no means of limiting how many instantiations of a particular facility there might be (not even via standard facilities). Thus, in terms of specifying concepts such as clocks, LED strips, and other hardware-centric concepts that only appear once on circuit board, RESOLVE might benefit from an in-language mechanism that restricts allowable instances of these and other objects. 

\section{Conclusions}

In this paper we present new RESOLVE language constructs and tools with the objective of translating RESOLVE to embedded platform friendly C. We provide representative specifications of an LED strip component that both demonstrates the benefits of RESOLVE's approach to reusable mathematical developments, as well as formal verification of a single driver enhancement. We illustrate usage of this component in the context of a client facility module, wherein we introduce the externally keyword that allows users to transparently pair non-native RESOLVE implementations with native RESOLVE specifications. We then translate this facility application, illustrating a proof-of-concept dynamic memory allocator working in tandem with what we consider to be an accurate C representation of RESOLVE code. The examples and results listed in this paper have been successfully run on a Telos mote, and the overall tool -- now fully integrated with the RESOLVE compiler -- actively continues to undergo improvements and optimizations on all fronts.
