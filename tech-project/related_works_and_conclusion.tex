\section{Related Work}

There are a number of existing systems that ultimately seek to prove the functional correctness of programs. While we discuss only two here, readers interested in learning more about the systems mentioned might to refer to \cite{klebanov:2011} for a more in depth discussion. Perhaps most notable among the systems we list here (and perhaps the closest to RESOLVE's approach) is Microsoft research's Dafny \cite{leino:2010}. Designed to be capable of verifying pointer based structures, Dafny currently stands as one of the more popular approaches to verification. Substituting RESOLVE's notion of mathematical variables with what are termed `ghost' variables, reasoning is kept, like RESOLVE, disconnected from implementation-level code. Dafny uses an intermediate verification language, termed Boogie, to generate verification conditions which are then dispatched via Z3, Microsoft's automated prover. 

Another system, also a Microsoft research endeavor, is VCC -- a system designed for the verification of C programs \cite{vcc:2009}. One of the main draws of VCC is that it has mechanisms for verification of concurrent code -- an ideal feature when presented with asynchronous, event driven code common in most embedded applications. 

RESOLVE differs from the projects mentioned above most notably in that it does not make use of third party automated provers or decision procedures to discharge verification conditions. Rather, it makes use of an integrated, minimalist term rewrite prover that applies higher order theorems and definitions in attempting to transform givens into a provable goal. 

% shortcoming -- concurrency.

\section{Discussion and Future Work}

Using embedded application development as an example, we perceive this work as a step towards more fully exploring the role of formal verification in lower level system-oriented contexts. Indeed, the realm of embedded systems provides an ideal stepping off point for this challenge, as it encourages (and indeed, requires) RESOLVE to provide support for not only new target languages (namely C), but also new language constructs that give the user the ability to author drivers required for any serious embedded application. While we have made progress with the latter in the form of the externally keyword, a natural direction for future work would entail using RESOLVE's performance specification mechanisms to prove the time and duration estimates for a memory allocator, not unlike the one presented here.

Further, an additional language characteristic that we feel would be beneficial is having some means of dictating \textit{static objects}. While RESOLVE makes considerations for single instance concepts that are tied to particular facility instantiations, we currently have no means of strictly limiting how many instantiations of a particular facility there might be (not even via standard facilities). Thus, in terms of specifying concepts such as clocks, LED strips, and other hardware-centric concepts that only appear once on a circuit board, RESOLVE could benefit from a mechanism that restricts allowable instances of these and other objects. 

\section{Conclusion}

In this paper we present a new RESOLVE language construct, and a translation tool that aims to produce an accurate, embedded platform-friendly C representation of RESOLVE. We provide representative specifications of an LED strip component that both demonstrates the benefits of RESOLVE's approach to reusable mathematical developments, as well as formal verification of a single driver enhancement. We illustrate usage of this component in the context of a client facility module, wherein we introduce the externally keyword that allows users to transparently pair non-native RESOLVE implementations with native RESOLVE specifications. We then translate this facility application, illustrating a proof-of-concept dynamic memory allocator working in tandem with what we consider to be an accurate C representation of RESOLVE code. The examples and results listed in this paper have been successfully run on a Telosb mote, and the overall tool -- now fully integrated with the RESOLVE compiler -- actively continues to undergo improvements and optimizations on all fronts.
